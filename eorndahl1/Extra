So, what we have here spits out a large float which is then converted by two operations.

The float is generated by multiplying a hexadecimal number by a function of x and then adding
this to 5 more operations like this.

After investigating this madness we get...

-25960.000000
0.000000
0.000000
0.000000
0.000000
0.000000

0.000000
27756.000000
-0.000000
-0.000000
-0.000000
-0.000000

-0.000000
-0.000000
-8303.000000
0.000000
0.000000
0.000000

0.000000
0.000000
0.000000
28535.000000
-0.000000
-0.000000

-0.000000
-0.000000
-0.000000
-0.000000
-27762.000000
0.000000

0.000000
0.000000
0.000000
0.000000
0.000000
2660.000000

So now we see that the equations are preformatted to only spit out an answer from one function per x increment
(The numerator will multiply by a 0 for the other 5). This turns out to be exactly the hexadecimal value so the
increment value cancels out the function it was supposed to multiply with. This float's absolute value is then
cast into an unsigned int which will then give us two characters depending on how it's operated on.

The first operation masks the float to extract the last byte whose decimal is an ascii char value.

The second one does 8 bitwise right shifts whose decimal is also an ascii char value.

104 101
he
108 108
ll
111 32
o
119 111
wo
114 108
rl
100 10
d

Together, as you can see, these two operations extract two characters at a time, printing out "hello world" in 6 loop
iterations. And I wish I could say how the floats were originally found but I'm stumped -_- I suppose maybe Dr Harrison
has an obfuscation algorithm since it seems pretty impossble to just manually think up this kind of thing (at least
to my n3wb mind).
